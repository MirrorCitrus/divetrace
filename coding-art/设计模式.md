> 盗图

# 命令模式
**概述和使用场景**
当我们需要把调用方和接收方解耦，对调用本身进行一些控制的时候，需要使用命令模式。
典型的控制包括：undo、redo、请求排队、记录请求日志、事务型操作等。
命令本身需要支持哪些功能也很好地封装了起来（比如所有命令都要支持execute和undo），后续添加也很方便。

**类图、结构和角色介绍**

![类图](/assets/command-1.png)
- **命令角色（Command）**：定义命令的接口。
- **具体命令角色（ConcreteCommand）**：命令接口的实现对象，持有接收者。
- **接受者角色（Receiver）**：真正执行命令的对象。
- **客户角色（Client）**：持有Receiver和Invoker对象（维系调用者和接收者的联系），同时也创建具体的Command。类似于输入源/触发点。
- **调用者角色（Invoker）**：Invoker角色应该是这个模式比较重要的设计，试想如果直接从client创建command再调用cmd.execute，则失去了对（多）命令的控制了。所以client对命令要做什么操作，必然要通过invoker来转接。Invoker可以方便地进行封装，最终只暴露给Client最简单的接口。



# 桥接模式
**概述和使用场景**
当需求中有两个维度的内容需要变化的时候，需要使用桥接模式。

**类图、结构和角色介绍**
![类图](/assets/bridge1.png)
* 抽象化(Abstraction)角色：
* 修正抽象化(Refined Abstraction)角色：
* 实现化(Implementor)角色：
* 具体实现化(ConcreteImplementor)角色：

**Android中的例子**
ListView和ListAdapter
![ListView和ListAdapter](/assets/bridge2.png)

# 参考
* [Android源码设计模式分析项目
](https://github.com/simple-android-framework/android_design_patterns_analysis)